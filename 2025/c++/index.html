<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++学习笔记 | Triority's blog</title><meta name="author" content="Triority"><meta name="copyright" content="Triority"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要内容这篇文章是c++的学习笔记，仅作为我自己的备忘录使用，不包含我已经非常熟悉的内容，所以不适合入门看哦，最好有其他语言基础，当然我猜这玩意也没人看（） 所有示例程序都是我自己重新写的简化举例可放心参考。 开发环境windows下开发：VS studio目前最新版本是2022，直接下载安装就能用，一切都已经准备好了 其他情况一些开源开发者朋友们得知我要学一遍c++，非常热情的想要教会我，并且建">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="http://triority.cc/2025/c++/index.html">
<meta property="og:site_name" content="Triority&#39;s blog">
<meta property="og:description" content="主要内容这篇文章是c++的学习笔记，仅作为我自己的备忘录使用，不包含我已经非常熟悉的内容，所以不适合入门看哦，最好有其他语言基础，当然我猜这玩意也没人看（） 所有示例程序都是我自己重新写的简化举例可放心参考。 开发环境windows下开发：VS studio目前最新版本是2022，直接下载安装就能用，一切都已经准备好了 其他情况一些开源开发者朋友们得知我要学一遍c++，非常热情的想要教会我，并且建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://triority.cc/img/C_grass.jpg">
<meta property="article:published_time" content="2025-01-23T09:33:04.000Z">
<meta property="article:modified_time" content="2025-10-16T14:58:41.781Z">
<meta property="article:author" content="Triority">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://triority.cc/img/C_grass.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://triority.cc/2025/c++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":10,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-16 14:58:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style type="text/css">
.spoiler {
  display: inline-flex;
}
p.spoiler {
  display: flex;
}
.spoiler a {
  pointer-events: none;
}
.spoiler-blur, .spoiler-blur > * {
  transition: text-shadow .5s ease;
}
.spoiler .spoiler-blur, .spoiler .spoiler-blur > * {
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  text-shadow: 0 0 10px grey;
  cursor: pointer;
}
.spoiler .spoiler-blur:hover, .spoiler .spoiler-blur:hover > * {
  text-shadow: 0 0 5px grey;
}
.spoiler-box, .spoiler-box > * {
  transition: color .5s ease,
  background-color .5s ease;
}
.spoiler .spoiler-box, .spoiler .spoiler-box > * {
  color: black;
  background-color: black;
  text-shadow: none;
}</style><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Triority's blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">124</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/services/"><i class="fa-fw fas fa-list"></i><span> 服务</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-book"></i><span> 相册</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/C_grass.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Triority's blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">Triority's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/services/"><i class="fa-fw fas fa-list"></i><span> 服务</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-book"></i><span> 相册</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-01-23T09:33:04.000Z" title="发表于 2025-01-23 09:33:04">2025-01-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%96%87%E6%A1%A3-%E7%AC%94%E8%AE%B0/">文档&amp;笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/c++/" data-flag-title="C++学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>这篇文章是c++的学习笔记，仅作为我自己的备忘录使用，不包含我已经非常熟悉的内容，所以不适合入门看哦，最好有其他语言基础，当然我猜这玩意也没人看（）</p>
<p>所有示例程序都是我自己重新写的简化举例可放心参考。</p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="windows下开发：VS-studio"><a href="#windows下开发：VS-studio" class="headerlink" title="windows下开发：VS studio"></a>windows下开发：VS studio</h2><p>目前最新版本是2022，直接下载安装就能用，一切都已经准备好了</p>
<h2 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h2><p>一些开源开发者朋友们得知我要学一遍c++，非常热情的想要教会我，并且建议我用vscode连接wsl在ubuntu虚拟机内使用clang&#x2F;msvc开发</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="数据类型长度和范围"><a href="#数据类型长度和范围" class="headerlink" title="数据类型长度和范围"></a>数据类型长度和范围</h2><p>c++标准没用固定值的规定，但是有最小标准：</p>
<ul>
<li><code>short</code>至少16位（-32,768 - 32,767）</li>
<li><code>int</code>至少于<code>short</code>一样长</li>
<li><code>long</code>至少32位（-2,147,483,648 - 2,147,483,647），且至少于<code>int</code>一样长</li>
<li><code>long long</code>至少64位（-9,223,372,036,854,775,808 - 9,223,372,036,854,775,807），且至少于<code>long</code>一样长（有的系统不支持）</li>
</ul>
<p>可以通过<code>#include &lt;climits&gt;</code>获取具体范围：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">int</span> n_int = INT_MAX;</span><br><span class="line">    <span class="type">short</span> n_short = SHRT_MAX;</span><br><span class="line">    <span class="type">long</span> n_long = LONG_MAX;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n_llong = LLONG_MAX;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes, maximum value: &quot;</span> &lt;&lt; n_int &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes, maximum value: &quot;</span> &lt;&lt; n_short &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes, maximum value: &quot;</span> &lt;&lt; n_long &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long long is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes, maximum value: &quot;</span> &lt;&lt; n_llong &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在我的64位windwos系统上结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int is 4 bytes, maximum value: 2147483647</span><br><span class="line">short is 4 bytes, maximum value: 32767</span><br><span class="line">long is 4 bytes, maximum value: 2147483647</span><br><span class="line">long long is 4 bytes, maximum value: 9223372036854775807</span><br></pre></td></tr></table></figure>

<h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    MyStruct the_string;</span><br><span class="line">    cin &gt;&gt; the_string.str;</span><br><span class="line">    the_string.len = the_string.str.<span class="built_in">length</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Length of &quot;</span>  &lt;&lt; the_string.str &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; the_string.len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针相关操作"><a href="#指针相关操作" class="headerlink" title="指针相关操作"></a>指针相关操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> num = <span class="number">10.0</span>;</span><br><span class="line">    <span class="comment">//地址p为double*类型，值设置为取num的地址</span></span><br><span class="line">    <span class="type">double</span>* p = &amp;num;</span><br><span class="line">    <span class="comment">//输出:00000004664FF714指向的值为1</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态数组（动态联编）和赋值</span></span><br><span class="line">    <span class="type">int</span>* pz = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">5</span>];</span><br><span class="line">    *pz = <span class="number">1</span>;</span><br><span class="line">    pz[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    *(pz + <span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; pz &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; pz[<span class="number">0</span>] &lt;&lt; pz[<span class="number">1</span>] &lt;&lt; pz[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用完成后释放（如果new有[]那么del时候要写[]，反之亦然）</span></span><br><span class="line">    <span class="keyword">delete</span> [] pz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态结构操作</span></span><br><span class="line">    MyStruct* ps = <span class="keyword">new</span> MyStruct;</span><br><span class="line">    <span class="comment">//使用-&gt;运算符访问成员</span></span><br><span class="line">    ps-&gt;str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">    <span class="comment">//使用地址访问成员</span></span><br><span class="line">    std::cout &lt;&lt; (*ps).str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="简单IO"><a href="#简单IO" class="headerlink" title="简单IO"></a>简单IO</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入ofstream（覆盖原内容）</span></span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;info.txt&quot;</span>);</span><br><span class="line">    string str0;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str0);</span><br><span class="line">    outfile &lt;&lt; str0;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取ifstream</span></span><br><span class="line">    ifstream infile;</span><br><span class="line">    infile.<span class="built_in">open</span>(<span class="string">&quot;info.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!infile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">while</span> (infile.<span class="built_in">good</span>())&#123;</span><br><span class="line">        <span class="built_in">getline</span>(infile,str1);</span><br><span class="line">        cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数应用"><a href="#函数应用" class="headerlink" title="函数应用"></a>函数应用</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>函数前加<code>inline</code>，编译器将函数代码替换函数调用，减少跳转导致的时间消耗</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">square</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">square</span>(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数引用变量"><a href="#函数引用变量" class="headerlink" title="函数引用变量"></a>函数引用变量</h3><p>使用引用变量作为函数参数，函数将使用原始数据而不是其副本，可用于函数处理大型结构或进行类的设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> &amp; number = num;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    number++;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外需要注意，引用变量必须在创建时初始化，而且无法修改关联的变量。</p>
<p>使用结构引用参数只需在声明结构参数时使用引用运算符<code>&amp;</code>即可。例如如下结构定义，函数原型应该这样编写，从而在函数中将指向该结构的引用作为参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">STRUCT</span>&#123;</span><br><span class="line">    std:string name;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUNC</span><span class="params">(STRUCT &amp; s)</span></span>;</span><br><span class="line"><span class="comment">//如果不希望函数修改传入的结构可使用const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUNC</span><span class="params">(<span class="type">const</span> STRUCT &amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数重载"><a href="#参数重载" class="headerlink" title="参数重载"></a>参数重载</h3><p>可以通过函数重载来设计一系列函数，他们名称相同，完成相同的操作，但是使用不同的参数列表（他们的返回值类型也可以不一样）。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>可以使用泛型来定义函数，避免了对函数多次几乎相同的编写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a , b = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a , b = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">11.4</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">51.4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c , d = &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Swap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c , d = &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件应该包含以下内容：</p>
<ul>
<li>函数原型</li>
<li>使用<code>#define</code>或<code>const</code>定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ul>
<p>在包含头文件时，应使用<code>a.h</code>而不是<code>&lt;a.h&gt;</code>，后者编译器会在存储标准头文件的位置查找，而前者先在当前工作目录查找，如果没用找到再去标准位置。</p>
<p>为了避免包含同一个头文件多次（可能包含了另一个包含某个头文件的头文件），可以使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STH</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h3><ul>
<li>自动存储：函数中定义将在函数结束后释放。</li>
<li>静态存储：在函数外定义的变量和用关键字<code>static</code>定义的变量。在整个程序运行过程中存在。<ul>
<li>链接性为外部，可在其他文件访问，必须在代码块外声明。在一个文件中定义，其他文件使用<code>extern</code>关键字声明。</li>
<li>链接性为内部，只能在当前文件访问，必须在代码块外声明并使用<code>static</code>限定符</li>
<li>无链接性，只能在当前函数或代码块内访问，必须在代码块内声明并使用<code>static</code>限定符</li>
</ul>
</li>
<li>线程存储：使用关键字<code>thread_local</code>声明，其生命周期和其所属线程一样长</li>
<li>动态存储：使用<code>new</code>关键字分配，一直存在直到使用<code>delete</code>将其释放或程序结束。也被称为自由存储（free store）或堆（heap）</li>
</ul>
<h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><p>存储说明符：</p>
<ul>
<li>auto（c++11中不再是说明符）</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>thread_local（c++11新增的）</li>
<li>mutable</li>
</ul>
<p>限定符：</p>
<ul>
<li>const</li>
<li>volatile（避免编译器进行将数据复制到寄存器的优化，因为硬件等可能对其进行修改，例如串口信息）</li>
<li>mutable（用于指出即使结构或类为const，其某个成员也可以进行修改）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accesses;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> data veep = &#123;<span class="string">&quot;a&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(veep.name, <span class="string">&quot;abc&quot;</span>);<span class="comment">//not allowed</span></span><br><span class="line">veep.accesses++;<span class="comment">//allowed</span></span><br></pre></td></tr></table></figure>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>两个名称空间的相同名称将不会导致冲突。下面的代码使用新的关键字<code>namespace</code>创建了一个新的名称空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Triority&#123;</span><br><span class="line">    <span class="type">int</span> sth;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>名称空间可以是全局的也可以位于其他名称空间中，但是不能在代码块中。默认情况下其链接性为外部的（除非引用了常量）</p>
<p>标记一下，这一段我没写完，我要先去写cmake</p>
<h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><h3 id="简要介绍和安装"><a href="#简要介绍和安装" class="headerlink" title="简要介绍和安装"></a>简要介绍和安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">完成C++项目的执行过程， 主要是分为四步: 预处理、编译、汇编、链接。g++命令确实可以对一个C++项目通过上面四步转成可执行文件，但在中大型项目里面，这样还是太复杂。 于是乎就有了MakeFile。</span><br><span class="line">Makefile 文件描述了 Linux 系统下 C/C++ 工程的编译规则，它用来自动化编译 C/C++ 项目。一旦写编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。</span><br><span class="line">CMake是简化MakeFile编写，可以自动生成MakeFile文件</span><br><span class="line">CMake是一个跨平台的编译(Build)工具，可以用简单的语句来描述所有平台的编译过程，其是在make基础上发展而来的，早期的make需要程序员写Makefile文件，进行编译，而现在CMake能够通过对cmakelists.txt的编辑，轻松实现对复杂工程的组织</span><br><span class="line"></span><br><span class="line">cmake编译流程：</span><br><span class="line">1. 编写Cmake配置文件CMakeLists.txt, 理解成Cmake所要处理的代码</span><br><span class="line">2. 执行命令 cmake path生成MakeFile, path是CmakeList.txt所在目录</span><br><span class="line">3. 使用make命令进行编译</span><br></pre></td></tr></table></figure>
<p>安装cmake并查看版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure>
<h3 id="目录组织"><a href="#目录组织" class="headerlink" title="目录组织"></a>目录组织</h3><ul>
<li>项目根目录下建立<code>build</code>文件夹并建立<code>CMakeLists.txt</code>文件（和.cpp和.h在一起，这里只是最简单的演示文件）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.28)</span><br><span class="line"></span><br><span class="line"># set the project name</span><br><span class="line">project(main)</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(main 1.cpp main.cpp)</span><br></pre></td></tr></table></figure></li>
<li>build文件夹内使用cmake生成makefile  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ../.</span><br></pre></td></tr></table></figure></li>
<li>编译项目  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li>
<li>执行程序  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>
<img src="/2025/c++/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20250126175713.png"></li>
</ul>
<h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><p>这里面的大部分命令都是固定语法，相当于我们只需要指定一些参数即可。 先整理上面几个命令，如果有其他命令需要用到，可以<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/v2.8.8/cmake.html#section_Commands">去官网查看具体使用</a>（当然这个页面我觉得不会有人愿意看）</p>
<ul>
<li>cmake_minimum_required命令<ul>
<li><code>cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR])</code></li>
<li>用于指定需要的CMake 的最低版本</li>
<li>示例：<code>cmake_minimum_required(VERSION 3.28)</code></li>
</ul>
</li>
<li>project命令<ul>
<li><code>project( [languageName1 languageName2 … ] )</code></li>
<li>用于指定项目的名称，一般和项目的文件名称对应</li>
<li>示例：<code>project(main)</code></li>
</ul>
</li>
<li>add_executable命令<ul>
<li><code>add_executable( [WIN32] [MACOSX_BUNDLE][EXCLUDE_FROM_ALL] source1 source2 … sourceN)</code></li>
<li>用于指定从一组源文件 source1 source2 … sourceN 编译出一个可执行文件且命名为name</li>
<li>示例：<code>add_executable(main 1.cpp main.cpp)</code></li>
</ul>
</li>
<li>include_directories命令<ul>
<li><code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</code></li>
<li>用于设定目录，这些设定的目录将被编译器用来查找 include 文件</li>
</ul>
</li>
</ul>
<h4 id="vscode自动生成CMakeLists-txt"><a href="#vscode自动生成CMakeLists-txt" class="headerlink" title="vscode自动生成CMakeLists.txt"></a>vscode自动生成CMakeLists.txt</h4><p>利用vscode中的cmaketools插件，可以自动生成cmakelist文件，例如需要include两个头文件生成就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5.0)</span><br><span class="line">project(main VERSION 0.1.0 LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line">add_executable(main 1.cpp 2.cpp main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在vscode安装<code>cmake</code>,<code>CMake Tools</code>,<code>Makefile Tools</code>三个插件，<code>Ctrl+shift+p</code>调出VSCode的指令面板，输入<code>cmake</code>，找到<code>cmake:quick start</code>，按照提示填写一个项目的名称，选择C++orC，选择构建库或者可执行文件，我这里只需要一个可执行文件，然后就会自动帮你生成一个CMakeLists</p>
<h2 id="OOP：面向对象"><a href="#OOP：面向对象" class="headerlink" title="OOP：面向对象"></a>OOP：面向对象</h2><h3 id="类的定义和使用"><a href="#类的定义和使用" class="headerlink" title="类的定义和使用"></a>类的定义和使用</h3><p><code>a_class.h</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//默认就是private，也可以不写这个关键字</span></span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="type">long</span> shares;</span><br><span class="line">    <span class="type">double</span> share_val;</span><br><span class="line">    <span class="type">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        total_val = shares * share_val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数用于初始化</span></span><br><span class="line">    <span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n = <span class="number">0</span>, <span class="type">double</span> pr = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="comment">//const成员函数，保证函数不会修改调用对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//析构函数,一般不应显式调用，如果没用定义将隐式生成，用于完成清理工作，例如进行delate内存释放</span></span><br><span class="line">    ~<span class="built_in">Stock</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>a_class.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>&#123;</span><br><span class="line">    shares += num;</span><br><span class="line">    share_val = price;</span><br><span class="line">    <span class="built_in">set</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Company:&quot;</span> &lt;&lt; company &lt;&lt; std::endl </span><br><span class="line">        &lt;&lt; <span class="string">&quot;Shares:&quot;</span> &lt;&lt; shares &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Share Price:&quot;</span> &lt;&lt; share_val &lt;&lt; std::endl </span><br><span class="line">        &lt;&lt; <span class="string">&quot;Total Worth:&quot;</span> &lt;&lt; total_val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)&#123;</span><br><span class="line">    company = co;</span><br><span class="line">    shares = n;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    <span class="built_in">set</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::~<span class="built_in">Stock</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DEL &quot;</span> &lt;&lt; company &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function">Stock <span class="title">triority</span><span class="params">(<span class="string">&quot;Triority&quot;</span>)</span></span>;</span><br><span class="line">    triority.<span class="built_in">buy</span>(<span class="number">114514</span>, <span class="number">3.1415926</span>);</span><br><span class="line">    triority.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要创建同一个类的多个对象，可以这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock stocks[<span class="number">4</span>];</span><br><span class="line">stocks[<span class="number">0</span>].<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>
<p>如果使用构造函数则必须这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stock stocks[<span class="number">2</span>] = &#123;</span><br><span class="line">    <span class="built_in">Stock</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Stock</span>(<span class="string">&quot;b&quot;</span>, <span class="number">1.0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>在 C++ 中，this指针是一个特殊的指针，它指向当前对象的实例。每一个对象都能通过this指针来访问自己的地址。可以在类的成员函数中使用，可以用来指向调用对象。</p>
<p>当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。</p>
<p>通过使用 this 指针，我们可以在成员函数中访问当前对象的成员变量，即使它们与函数参数或局部变量同名，这样可以避免命名冲突，并确保我们访问的是正确的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>假设有一个Time类包含hours和minutes变量，求和的函数方法大概是这样<br><code>time.h</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">Time::Sum</span><span class="params">(<span class="type">const</span> Time &amp; t)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>time.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">Time::Sum</span><span class="params">(<span class="type">const</span> Time &amp; t)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes/<span class="number">60</span></span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要使用加法运算符进行这个操作，只需要把<code>Sum()</code>的名称改为<code>operator+()</code>即可<br><code>time.h</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p><code>time.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t) <span class="type">const</span>&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes/<span class="number">60</span></span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后计算时间总和就可以直接用<code>+</code>了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_total = time_1 + time_2;</span><br></pre></td></tr></table></figure>

<p>重载的使用有一些限制：</p>
<ul>
<li>重载后必须至少有一个操作数是用户定义的类型，避免用户为标准类型重载，比如重载<code>-</code>符号为求和</li>
<li>不能修改运算符优先级</li>
<li>重载不能违反原来的句法规则，比如将求模<code>%</code>重载成只用一个操作数</li>
<li>不能创建新的运算符</li>
<li>一些不能重载的运算符：<code>sizeof</code>等（懒得全写一遍了，这玩意估计八百年用不到一次）</li>
</ul>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类对象的公有类发布方法是访问对象私有部分的唯一途径，但是这种限制有时候过于严格，因此提供了友元的概念，包括友元函数，友元类，友元成员函数。通过让函数成为类的友元可以赋予函数与类的成员函数相同的访问权限</p>
<p>在刚才的例子中可以实现时间的加法，那如果是乘法呢？由于运算符左侧是操作数，我们只能<code>A = B * double</code>而不能<code>A = double * B</code>，因为这个<code>double</code>不是对象。另一种解决方式就是使用友元</p>
<p>创建友元函数只要将其原型放在类声明中，并在前面加上<code>friend</code>关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="type">double</span> m, <span class="type">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure>
<p>显然这个函数在类声明中调用但是不是成员函数，但是拥有成员函数一样的访问权限</p>
<p>因为他不是成员函数，所以编写定义时不要使用<code>Time::</code>限定符，也不要使用关键字<code>friend</code>，应该这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="type">double</span> m, <span class="type">const</span> Time &amp; t)&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="type">long</span> totalminutes = t.hours *m * <span class="number">60</span> + t.minutes * m;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这些声明和定义之后，就可以使用这一语句了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time_A = <span class="number">2.75</span> * Time_B</span><br></pre></td></tr></table></figure>

<h3 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h3><p>c++会自动转换兼容的类型，比如<code>int a = 3.5;</code>会只保留整数部分，不兼容的类型不会自动转换，但是也许可以强制类型转换<code>int * p = (int *) 10;</code>，因为<code>p</code>和<code>(int *)</code>都是指针，虽然这样的转换大概率毫无意义</p>
<p>对于类，当构造函数只接受一个参数时（或者其他参数有默认值），可以编写这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AClass</span>(<span class="type">int</span> a);</span><br><span class="line"></span><br><span class="line">AClass aclass;</span><br><span class="line">aclass = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要避免意外的这种转换，可以在声明构造函数时使用关键字<code>explicit</code>，从而关闭隐式转换，但仍然允许显式转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AClass aclass;</span><br><span class="line">aclass = <span class="built_in">AClass</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">aclass = (AClass) <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>转换函数可以反过来将类对象转换为一个值，这是一种用户定义的强制类型转换。要创建一个转换函数要注意，转换函数必须是类方法，不能指定返回类型，而且不能有参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换为double类型的函数的原型，添加到类的声明中</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//或者int，出于严谨也可以加入const</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后在类定义中加入转换的方法（int返回double+0.5可以巧妙地四舍五入而不是丢弃小数部分）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AClass::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span> (pounds + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用时候便可以直接使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a_int = aclass;</span><br></pre></td></tr></table></figure>
<h3 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h3><p>使用<code>new</code>初始化对象的指针成员时应该注意一些事情：</p>
<ul>
<li>在构造函数中使用<code>new</code>初始化之后，应该在析构函数中使用<code>delete</code>，且必须互相兼容<code>new</code>对应<code>delete</code>且<code>new[]</code>对应于<code>delete[]</code></li>
<li>如果要进行对象的复制，应定义一个复制构造函数，进行实际内容的复制，而非指针。例如<code>b.str</code>是通过<code>new</code>创建的，类似<code>a.str = b.str</code>这样的直接复制只会复制地址，导致两个成员实际上指向同一份内容，并在当其中一个执行<code>delete</code>时导致数据损坏</li>
<li>也应该定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。具体来说，应该首先检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不是地址，返回一个指向调用对象的引用</li>
</ul>
<p>这部分内容可能比较难懂，需要一些举例才能完全理解，但是我现在又懒得在这补充一大堆代码作为举例，因此这件事交给未来的自己吧。在此之前可以直接阅读原书的P356</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>假设已经有了下面这个类（由前面的例子删减而来）<br><code>1.h</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="type">long</span> shares;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ~<span class="built_in">Stock</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>1.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Company:&quot;</span> &lt;&lt; company &lt;&lt; std::endl </span><br><span class="line">        &lt;&lt; <span class="string">&quot;Shares:&quot;</span> &lt;&lt; shares &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n)&#123;</span><br><span class="line">    company = co;</span><br><span class="line">    shares = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::~<span class="built_in">Stock</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DEL &quot;</span> &lt;&lt; company &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我现在想要让这个类新增一个<code>id</code>成员，但是不想改动已有的代码（甚至可能没有源代码），那么可以直接派生出一个类：<br><code>2.h</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;1.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock_id</span> : <span class="keyword">public</span> Stock&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stock_id</span>(<span class="type">long</span> i, std::string co, <span class="type">long</span> n = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_id</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>2.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock_id::show_id</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    Stock_id::<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock_id::<span class="built_in">Stock_id</span>(<span class="type">long</span> i, std::string co, <span class="type">long</span> n) : <span class="built_in">Stock</span>(co, n)&#123;</span><br><span class="line">    id = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类需要自己的构造函数，也可以添加额外的数据成员和成员函数</p>
<p>但是注意不能直接访问基类的私有成员而必须通过基类方法进行访问，也就是说，<code>private</code>只能这个类自己访问，<code>protected</code>允许自己和派生类访问，<code>public</code>允许全部访问</p>
<p>派生类继承了所有的基类方法，但下列情况除外：基类的构造函数、析构函数和拷贝构造函数，基类的重载运算符，基类的友元函数。</p>
<h3 id="多态继承"><a href="#多态继承" class="headerlink" title="多态继承"></a>多态继承</h3><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y,z;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter 2 nums:&quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;y = 0 is not allowed!&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">catch</span>(<span class="type">const</span> <span class="type">char</span> * s)&#123;</span><br><span class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        z = x/y;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x / y is:&quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>try</code>捕获异常，然后在<code>catch()</code>中对异常进行处理。（异常是新增的内容，一些老式编译器可能不支持）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">triority@Triority-Desktop:~/c++l/build$ /home/triority/c++l/build/main</span><br><span class="line">Enter 2 nums:114 514</span><br><span class="line">x / y is:0.22179</span><br><span class="line">Enter 2 nums:114514 0</span><br><span class="line">y = 0 is not allowed!</span><br><span class="line">Enter 2 nums:^C</span><br></pre></td></tr></table></figure>

<div class="note danger modern"><p>这一部分原来书上的代码<code>catch (char* str)</code>运行会报错<code>terminate called after throwing an instance of &#39;char const*&#39;</code>，这里是我改正且简化的版本。<br>原因是应该捕获const异常<code>catch (const char const* strException)</code>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24458563/throwing-exceptions-error-terminate-called">参考链接</a>中还讨论了更加规范的错误处理方法和其他”style note: This tutorial smells, maybe you should find another source.”😨😨😨</p>
</div>

<p>想让<code>catch</code>块能够处理<code>try</code>块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号<code>...</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者可以连续使用<code>catch</code>来分别处理多种异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="built_in">catch</span>(exc_a)&#123;</span><br><span class="line">&#125;<span class="built_in">catch</span>(exc_b)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常引发异常的函数会传递一个对象，从而可以使用不同的异常类型来区分不同函数在不同情况下引发的异常。对象也可以携带可以确定异常原因的信息。C++提供了一系列标准的异常，定义在<code>&lt;exception&gt;</code>中，我们可以在程序中使用这些标准的异常，或者通过继承和重载<code>exception</code>类来定义新的异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用的类和模板：string类-智能指针-STL标准模板库"><a href="#常用的类和模板：string类-智能指针-STL标准模板库" class="headerlink" title="常用的类和模板：string类,智能指针,STL标准模板库"></a>常用的类和模板：string类,智能指针,STL标准模板库</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>使用<code>new</code>分配内存时别忘了要<code>delete</code>释放内存，但是别忘了这件事总是不可靠的。如果指针是一个对象就可以在过期时调用析构函数释放内存该有多好，这就是智能指针对象。</p>
<p>在C++11及之后的版本中，最常见的智能指针类型包括<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。</p>
<ul>
<li><code>std::unique_ptr</code>提供了独占所有权的语义，确保同一时间内只有一个智能指针指向特定的资源。在<code>std::unique_ptr</code>的生命周期结束时，它会自动释放所拥有的资源，无需程序员手动干预。</li>
<li><code>std::shared_ptr</code>实现了共享所有权模型，允许多个智能指针共同拥有对同一资源的引用。这种模型通过引用计数来实现，每当一个新的<code>std::shared_ptr</code>被创建并指向同一资源时，引用计数会增加；当<code>std::shared_ptr</code>被销毁时，引用计数减少。只有当引用计数降至零时，资源才会被释放。<code>std::shared_ptr</code>的使用也带来了循环引用的问题，这时</li>
<li><code>std::weak_ptr</code>提供了一种不控制对象生命周期的智能指针，它指向由<code>std::shared_ptr</code>管理的对象，但不增加引用计数。这允许程序员访问资源，同时避免循环引用导致的内存泄漏。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Report</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Report</span>(<span class="type">const</span> std::string s) : <span class="built_in">str</span>(s)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Report</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object deleted!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using unique_ptr&quot;</span>))</span></span>;</span><br><span class="line">    ps -&gt; <span class="built_in">comment</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">triority@Triority-Desktop:~/c++l/build$ /home/triority/c++l/build/main</span><br><span class="line">Object created!</span><br><span class="line">using unique_ptr</span><br><span class="line">Object deleted!</span><br></pre></td></tr></table></figure>

<h3 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h3><blockquote>
<p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p>
<p>STL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p>
</blockquote>
<p>C++ 标准模板库的核心包括以下重要组件组件：</p>
<ul>
<li>容器（Containers）：容器是 STL 中最基本的组件之一，提供了各种数据结构，包括向量（vector）、链表（list）、队列（queue）、栈（stack）、集合（set）、映射（map）等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器。</li>
<li>算法（Algorithms）：STL 提供了大量的算法，用于对容器中的元素进行各种操作，包括排序、搜索、复制、移动、变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。</li>
<li>迭代器（iterators）：迭代器用于遍历容器中的元素，允许以统一的方式访问容器中的元素，而不用关心容器的内部实现细节。STL 提供了多种类型的迭代器，包括随机访问迭代器、双向迭代器、前向迭代器和输入输出迭代器等。</li>
<li>函数对象（Function Objects）：函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL 提供了多种函数对象，包括一元函数对象、二元函数对象、谓词等，可以满足不同的需求。</li>
<li>适配器（Adapters）：适配器用于将一种容器或迭代器适配成另一种容器或迭代器，以满足特定的需求。STL 提供了多种适配器，包括栈适配器（stack adapter）、队列适配器（queue adapter）和优先队列适配器（priority queue adapter）等。</li>
</ul>
<h4 id="容器矢量vector"><a href="#容器矢量vector" class="headerlink" title="容器矢量vector"></a>容器矢量vector</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line">    <span class="comment">// 添加元素到向量中</span></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="comment">// 访问向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector)std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 访问向量中的第一个元素myVector[0]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; myVector[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 获取向量的大小myVector.size()</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 定义一个迭代器，也可以使用auto语法</span></span><br><span class="line">    <span class="comment">// auto pd = myVector.begin();</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator pd = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 删除向量中的第2个元素，迭代器的行为和指针很相似，erase函数也可以接受两个迭代器参数进行[区间)删除</span></span><br><span class="line">    myVector.<span class="built_in">erase</span>(++pd);</span><br><span class="line">    <span class="comment">// 输出删除元素后的向量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector after erasing: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector)std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//除此以外还有insert()等其他方法，不再单独举例，insert接受三个迭代器参数，插入位置，要插入的容器对象的起始和结束位置</span></span><br><span class="line">    <span class="comment">// 清空向量</span></span><br><span class="line">    myVector.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector after clearing: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于范围的循环和迭代器"><a href="#基于范围的循环和迭代器" class="headerlink" title="基于范围的循环和迭代器"></a>基于范围的循环和迭代器</h4><p>这段内容作为一些补充，考虑到前面没有提到循环这些语法</p>
<p>基于范围的for循环就是为了用于STL而设计的，上面的写法<code>for (int element : myVector)&#123;&#125;;</code>就是遍历整个容器的内容，方便一点可以使用<code>auto</code>语法<code>for (auto x : myVector) do_something(x);</code>，使用引用参数也可以在遍历的同时修改元素内容<code>for (auto &amp; x : myVector) do_something(x);</code></p>
<p>STL规定了5种迭代器：</p>
<ul>
<li>输入迭代器（Input Iterator）：只能进行单次读取操作，不能进行写入操作。</li>
<li>输出迭代器（Output Iterator）：只能进行单次写入操作，不能进行读取操作。</li>
<li>正向迭代器（Forward Iterator）：可以进行读取和写入操作，并且可以向前移动。</li>
<li>双向迭代器（Bidirectional Iterator）：除了可以进行正向迭代器的所有操作外，还可以向后移动。</li>
<li>随机访问迭代器（Random Access Iterator）：除了可以进行双向迭代器的所有操作外，还可以进行随机访问，例如通过下标访问元素。</li>
</ul>
<p>不同容器的迭代器的功能也不同：</p>
<table>
<thead>
<tr>
<th align="center">容器</th>
<th align="center">迭代器功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vector</td>
<td align="center">随机访问</td>
</tr>
<tr>
<td align="center">deque</td>
<td align="center">随机访问</td>
</tr>
<tr>
<td align="center">list</td>
<td align="center">双向</td>
</tr>
<tr>
<td align="center">set &#x2F; multiset</td>
<td align="center">双向</td>
</tr>
<tr>
<td align="center">map &#x2F; multimap</td>
<td align="center">双向</td>
</tr>
<tr>
<td align="center">stack</td>
<td align="center">不支持迭代器</td>
</tr>
<tr>
<td align="center">queue</td>
<td align="center">不支持迭代器</td>
</tr>
<tr>
<td align="center">priority_queue</td>
<td align="center">不支持迭代器</td>
</tr>
</tbody></table>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><p>关联容器存储的元素，是由一个个“键值对”（key, value）组成。通过键，往往能很快的检索到对应的值。</p>
<p>关联容器可以快速查找、读取或者删除所存储的元素，同时该类型的容器插入元素的效率比序列容器高。</p>
<p>STL提供了4种关联容器：</p>
<ul>
<li><code>set</code>：关键字即值，即只保存关键字的容器。set类似一个集合，用来存储同类型的元素</li>
<li><code>multiset</code>：关键字可重复出现的set</li>
<li><code>map</code>：元素是一些键值对：关键字起到索引的作用，值则表示与索引相关联的数据，数据的存放是有序的</li>
<li><code>multimap</code>：关键字可以重复出现的map</li>
</ul>
<blockquote>
<p>C++ 11 还新增了 4 种哈希容器,即<code>unordered_map</code>、<code>unordered_multimap</code>以及<code>unordered_set</code>、<code>unordered_multiset</code>。严格来说,它们也属于关联式容器。哈希容器底层采用的是哈希表。</p>
</blockquote>
<p>这里以<code>map</code>为例简单介绍部分用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class="line">    std::map&lt;std::string, std::string, std::greater&lt;std::string&gt;&gt;myMap&#123; &#123;<span class="string">&quot;d&quot;</span>,<span class="string">&quot;4&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//向 map 容器添加新键值对</span></span><br><span class="line">    myMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;c&quot;</span>] = <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    <span class="comment">//输出当前 myMap 容器存储键值对的个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myMap size==&quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//判断当前 myMap 容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//借助 myMap 容器迭代器，将该容器的键值对逐个输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i)std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">triority@Triority-Desktop:~/c++l/build$ /home/triority/c++l/build/main</span><br><span class="line">myMap size==4</span><br><span class="line">d 4</span><br><span class="line">c 3</span><br><span class="line">b 2</span><br><span class="line">a 1</span><br></pre></td></tr></table></figure>

<h2 id="书上内容的结束"><a href="#书上内容的结束" class="headerlink" title="书上内容的结束"></a>书上内容的结束</h2><p>原书最后两章节继续介绍了c++的IO操作和c++11新内容总结，这部分内容我认为完全没有必要单独写出来，内容又多又杂但是没有难度，用的时候上网查便是。</p>
<p>如果我的这篇文章接着写下去我认为应该写一些应用功能了，例如并发编程或者opencv这些标准外的库的使用，这部分内容就交给未来勤奋的自己咯！ <del>是某个勤奋的面壁者吗？</del></p>
<h1 id="继续深造"><a href="#继续深造" class="headerlink" title="继续深造"></a>继续深造</h1><h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p>opencv的使用教程文章早已经写过，这里只写c++下需要进行的内容</p>
<p>OpenCV的功能被组织成多个模块，每个模块专注于不同的任务：</p>
<ul>
<li><code>Core</code>：提供基本数据结构和函数，如图像存储、矩阵操作、文件 I&#x2F;O 等。</li>
<li><code>Imgproc</code>：图像处理功能，包括滤波、几何变换、颜色空间转换、边缘检测、形态学操作等。</li>
<li><code>Highgui</code>：图像和视频的显示、窗口管理、用户交互（如鼠标事件、滑动条）。</li>
<li><code>Video</code>：视频处理功能，包括视频捕获、背景减除、光流计算等。</li>
<li><code>Calib3d</code>：相机标定、3D 重建、姿态估计等。</li>
<li><code>Features2d</code>：特征检测与描述，包括关键点检测、特征匹配等。</li>
<li><code>Objdetect</code>：目标检测功能，如 Haar 级联检测、HOG 检测等。</li>
<li><code>DNN</code>：深度学习模型的加载和推理，支持 TensorFlow、PyTorch、Caffe 等框架。</li>
<li><code>ML</code>：机器学习算法，如 KNN、SVM、决策树等。</li>
<li><code>Flann</code>：快速近似最近邻搜索（FLANN），用于特征匹配和高维数据搜索。</li>
<li><code>Photo</code>：图像修复、去噪、HDR 成像等。</li>
<li><code>Stitching</code>：图像拼接功能，用于创建全景图。</li>
<li><code>Shape</code>：形状分析和匹配。</li>
<li><code>Tracking</code>：目标跟踪算法，如 MIL、KCF、GOTURN 等。</li>
</ul>
<h3 id="安装和编译配置"><a href="#安装和编译配置" class="headerlink" title="安装和编译配置"></a>安装和编译配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libopencv-dev</span><br></pre></td></tr></table></figure>
<p>然后是编译配置<code>CMakeLists.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16.3)</span><br><span class="line"></span><br><span class="line"># set the project name</span><br><span class="line">project(main)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line">#about opencv output(Optional)</span><br><span class="line">message(STATUS &quot;Opnecv library status: &quot;)</span><br><span class="line">message(STATUS &quot;&gt; version: $&#123;OpenCV_VERSION&#125; &quot;)</span><br><span class="line">message(STATUS &quot;&gt; libraries: $&#123;OpenCV_LIBS&#125; &quot;)</span><br><span class="line">message(STATUS &quot;&gt; include: $&#123;OpenCV_INCLUDE_DIRS&#125;  &quot;)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># add the executable</span><br><span class="line">add_executable(main 1.cpp main.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(main $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于上面新增的内容做一些解释：</p>
<ul>
<li><code>find_package</code>：CMake 本身不提供任何关于搜索库的便捷方法，也不会对库本身的环境变量进行设置。它仅仅是按照优先级顺序在指定的搜索路径进行查找 Findxxx.cmake 文件和xxxConfig.cmake文件(其中xxx代表库的名字，特别注意的是有大小写之分)，这两个文件大体上是没有区别的，CMake 能够找到这两个文件中的任何一个，我们都能成功使用该库。</li>
<li><code>include_directories</code>：将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径</li>
<li><code>target_link_libraries</code>：该指令的作用为将目标文件与库文件进行链接</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>下面这个程序调用<code>wget</code>命令下载网站的图标（这一步是吃饱了撑的）然后显示图片</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;wget https://www.triority.cc/img/favicon.png&quot;</span>);</span><br><span class="line">    <span class="type">char</span> imageName[] = <span class="string">&quot;favicon.png&quot;</span>;</span><br><span class="line">    cv::Mat M = cv::<span class="built_in">imread</span>(imageName, cv::IMREAD_COLOR);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, M);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.triority.cc/">Triority</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://triority.cc/2025/c++/">http://triority.cc/2025/c++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://triority.cc" target="_blank">Triority's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/C_grass.jpg" data-sites="twitter,wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/SHE/" title="沈阳桃仙机场SHE拍摄活动"><img class="cover" src="/img/DSC1396.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">沈阳桃仙机场SHE拍摄活动</div></div></a></div><div class="next-post pull-right"><a href="/2025/Visual-SLAM/" title="本科毕业设计论文：巷道移动机器人SLAM技术研究"><div class="cover" style="background: /img/"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">本科毕业设计论文：巷道移动机器人SLAM技术研究</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Triority</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">124</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Triority"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Triority" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:triority@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The domain name of this website has been changed to triority.cc(Using CDN via cloudflare, recommended) / www.triority.cc(Connecting directly, works better in Chinese mainland). Please contact me if you have any questions.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">主要内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows%E4%B8%8B%E5%BC%80%E5%8F%91%EF%BC%9AVS-studio"><span class="toc-number">2.1.</span> <span class="toc-text">windows下开发：VS studio</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="toc-number">2.2.</span> <span class="toc-text">其他情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E5%92%8C%E8%8C%83%E5%9B%B4"><span class="toc-number">3.1.</span> <span class="toc-text">数据类型长度和范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">输入输出函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">指针相关操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95IO"><span class="toc-number">3.4.</span> <span class="toc-text">简单IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">函数应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">函数引用变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.5.3.</span> <span class="toc-text">参数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.5.4.</span> <span class="toc-text">函数模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">多文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.6.1.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7"><span class="toc-number">3.6.2.</span> <span class="toc-text">存储持续性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%92%8C%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.6.3.</span> <span class="toc-text">说明符和限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">3.6.4.</span> <span class="toc-text">名称空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">3.7.</span> <span class="toc-text">多文件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">3.7.1.</span> <span class="toc-text">简要介绍和安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87"><span class="toc-number">3.7.2.</span> <span class="toc-text">目录组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMakeLists-txt"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">CMakeLists.txt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vscode%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90CMakeLists-txt"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">vscode自动生成CMakeLists.txt</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.8.</span> <span class="toc-text">OOP：面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.8.1.</span> <span class="toc-text">类的定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">3.8.2.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">3.8.3.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">3.8.4.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.5.</span> <span class="toc-text">类的自动转换和强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.8.6.</span> <span class="toc-text">类和动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.8.7.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">3.8.8.</span> <span class="toc-text">多态继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">3.8.9.</span> <span class="toc-text">友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.9.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%EF%BC%9Astring%E7%B1%BB-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">3.10.</span> <span class="toc-text">常用的类和模板：string类,智能指针,STL标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">3.10.1.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.10.2.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">3.10.3.</span> <span class="toc-text">STL标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9F%A2%E9%87%8Fvector"><span class="toc-number">3.10.3.1.</span> <span class="toc-text">容器矢量vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.10.3.2.</span> <span class="toc-text">基于范围的循环和迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">3.10.3.3.</span> <span class="toc-text">关联容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A%E5%86%85%E5%AE%B9%E7%9A%84%E7%BB%93%E6%9D%9F"><span class="toc-number">3.11.</span> <span class="toc-text">书上内容的结束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E6%B7%B1%E9%80%A0"><span class="toc-number">4.</span> <span class="toc-text">继续深造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#opencv"><span class="toc-number">4.1.</span> <span class="toc-text">opencv</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">安装和编译配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget ads-wrap"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height=300 src="//music.163.com/outchain/player?type=0&id=9796678610&auto=0&height=430"></iframe></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By Triority</div><div class="footer_custom_text">阿美莉卡ICP备114514号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HCrr1LolVdHjaQ03fiyQnqO4-gzGzoHsz',
      appKey: 'SQPN055DPf1nyNHqYj5SBoo2',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>